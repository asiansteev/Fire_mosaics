---
title: "fire_analysis"
author: "Chris Adlam"
date: "7/16/2018"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load packages
```{r eval = F}
library(tidyverse)
library(emmeans)
library(lme4)
library(lmerTest)
library(pbkrtest)
library(car)
library(ggplot2)
library(cowplot)
library(reshape2)
library(splitstackshape)
library(magrittr)
library(readr)
library(vegan)
library(viridis)
library(cowplot)
library(purrr)
library(tibble)
library(broom)
library(labdsv)
library(indicspecies)
library(permute)
library(perm)
```

# Load the data
```{r include = FALSE}
# This loads the data
plant_data <- read.csv("/Users/christopheradlam/Desktop/Davis/R/GitHub Repos/Fire_mosaics/Data/plant_data.csv")
plant_names <- read.csv("/Users/christopheradlam/Desktop/Davis/R/GitHub Repos/Fire_mosaics/Data/plant_list.csv")
plant_data$species <- as.character(plant_data$species)
plant_data$site_id <- as.character(plant_data$site_id)
plant_names$species <- as.character(plant_names$species)
plant_names$full_name <- as.character(plant_names$full_name)
plant_names$native_status <- as.factor(plant_names$native_status)
plant_names$form <- as.factor(plant_names$form)

site_data <- read.csv("/Users/christopheradlam/Desktop/Davis/R/GitHub Repos/Fire_mosaics/Data/site_data.csv")
site_data$site_id <- as.character(site_data$site_id)
```

# Select data (pick one)
```{r eval = F}
# First convert data to wide format, then matrix
# CHECK FOR TYPOS - ALL GOOD
# missing <- anti_join(plant_data, plant_names, by = "species")

# Join file with data and file with plant info, then dplyr::select required information; dplyr::select and run the right one:
plant_dat <- left_join(plant_data, plant_names, by = "species") %>%
  filter(native_status == "native") %>%
  dplyr::select(site_id, species, cover)

plant_dat <- left_join(plant_data, plant_names, by = "species") %>%
  filter(native_status == "native" & form == "tree") %>%
  dplyr::select(site_id, species, cover)

plant_dat <- left_join(plant_data, plant_names, by = "species") %>%
  filter(native_status == "native" & form == "shrub") %>%
  dplyr::select(site_id, species, cover)

plant_dat <- left_join(plant_data, plant_names, by = "species") %>%
  filter(native_status == "native" & (form == "shrub" | form == "tree")) %>%
  dplyr::select(site_id, species, cover)

plant_dat <- left_join(plant_data, plant_names, by = "species") %>%
  filter(native_status == "native" & (form == "herb" | form == "grass")) %>%
  dplyr::select(site_id, species, cover)

plant_dat <- left_join(plant_data, plant_names, by = "species") %>%
  filter(native_status == "native" & (form == "herb")) %>%
  dplyr::select(site_id, species, cover)
```

# Data prep
```{r}
# convert to wide format for following analysis
plant_matrix1 <- spread(data = plant_dat, key = species, value = cover, fill = 0)

# optional:remove plants with few sightings; not sure this makes much difference
## add columns true/false depending on obs count reaching minimum value
plant_matrix <- rbind(plant_matrix1, c("colsum", colSums(plant_matrix1[, -1]) > 4))
## keep only columns where minimum is reached (true)
plant_matrix <- plant_matrix[, (plant_matrix[49, ]) == TRUE]
## adding back in the site id and removing true/false row (and making sure it's all read in as numeric)
plant_matrix <- cbind(site_id = plant_matrix1[, 1], plant_matrix[-49, ]) %>%
  mutate_if(is.character, as.numeric)

# Make Bray-Curtis (?) dissimilarity matrix
plants_matrix <- as.matrix(plant_matrix1[, -1])
```

#NMDS
##NMDS run using monoMDS
```{r eval = F}
# monoMDS allows for some more flexibility than metaMDS, eg. dplyr::selecting alternative MDS methods; one problem is that species can't be plotted along with sites.

plants_matrix_mono <- vegan::vegdist(plants_matrix, method = "bray")

NMDS <- monoMDS(plants_matrix_mono, k = 2, model = c("global"), maxit = 5000, weakties = TRUE, stress = 1, scaling = TRUE, pc = TRUE, smin = 1e-4, sfgrmin = 1e-7, sratmax = 0.99999)


# now trying to improve this code to directly plot NMDS results:
data_scores <- as.data.frame(scores(NMDS))  #Using the scores function from vegan to extract the site scores and convert to a data.frame
data_scores$site_id <- plant_matrix1[, 1]  # create a column of site names, from the rownames of data.scores
data_scores <- left_join(data_scores, site_data, by = "site_id") #  add the grp variable created earlier
  
head(data_scores)  #look at the data

# this part not working:
#species_scores <- as.data.frame(scores(NMDS, "species"))  #Using the scores function from vegan to extract the species scores and convert to a data.frame
#species_scores$species <- rownames(species_scores)  # create a column of species, from the rownames of species.scores
#head(species_scores)  #look at the data

hi <- data_scores[data_scores$sev == "h", ][chull(data_scores[data_scores$sev == 
    "h", c("MDS1", "MDS2")]), ]  # hull values for grp A
lo <- data_scores[data_scores$sev == "l", ][chull(data_scores[data_scores$sev == 
    "l", c("MDS1", "MDS2")]), ]  # hull values for grp B
un <- data_scores[data_scores$sev == "u", ][chull(data_scores[data_scores$sev == 
    "u", c("MDS1", "MDS2")]), ]  # hull values for grp B

hull.data <- rbind(hi, lo, un)  #combine grp.a and grp.b
hull.data

ggplot() + 
#  geom_polygon(data=hull.data,aes(x=MDS1,y=MDS2,fill=sev,group=sev),alpha=0.30) + # add the convex hulls
  #geom_text(data=species_scores,aes(x=MDS1,y=MDS2,label=species),alpha=0.5) +  # add the species labels
  geom_point(data=data_scores,aes(x=MDS1,y=MDS2,shape=sev,colour=sev),size=3) + # add the point markers
  geom_text(data=data_scores,aes(x=MDS1,y=MDS2,label=site_id),size=6,vjust=0) +  # add the site labels+
  stat_ellipse(data = data_scores, geom = "polygon", alpha = 0.05, aes(x=MDS1,y=MDS2, fill = sev), level = 0.8) +
  coord_equal() +
  theme_bw() + 
  theme(axis.text.x = element_blank(),  # remove x-axis text
        axis.text.y = element_blank(), # remove y-axis text
        axis.ticks = element_blank(),  # remove axis ticks
        axis.title.x = element_text(size=18), # remove x-axis labels
        axis.title.y = element_text(size=18), # remove y-axis labels
        panel.background = element_blank(), 
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank())

# old school plotting method:
#plot(NMDS)
#ordiplot(NMDS, type = "n")
#ordiellipse(NMDS, site_data$sev, display = "site_id", kind = "sd")
# ordihull(NMDS,groups=treat,draw="polygon",col="grey90",label=F)

```

##NMDS run using metaMDS
```{r}
# NMDS using metaMDS
NMDS <- metaMDS(plants_matrix, trymax = 5000, try = 100, k = 2)

# The following is meant for plotting the results (old school, not using ggplot), and also is used for the cluster analysis using dplyr:
site_data$tsf_cat <- as.factor(site_data$tsf_cat)
data_scores <- as.data.frame(scores(NMDS))  #Using the scores function from vegan to extract the site scores and convert to a data.frame
data_scores$site_id <- plant_matrix1[, 1]  # create a column of site names
data_scores <- left_join(data_scores, site_data, by = "site_id")

# this part not working but would be used for old school plotting:
#species_scores <- as.data.frame(scores(NMDS, "species"))  #Using the scores function from vegan to extract the species scores and convert to a data.frame
#species_scores$species <- rownames(species_scores)  # create a column of species, from the rownames of species.scores
```

```{r eval = F}
data_scores <- data_scores %>%
#  mutate_all(funs(ifelse(is.na(.), un, .))) %>% 
  mutate(tsf_cat2 = ifelse(tsf < 8 , "1", ifelse(tsf < 17, "2", ifelse(tsf < 35, "3", "4"))))
```

# Cluster analysis
## Cluster analysis using dplyr
```{r}
#kclust <- kmeans(data_scores, centers = 3)
# necessary if using monoMDS:
#data_scores$NMDS1 <- data_scores$MDS1
#data_scores$NMDS2 <- data_scores$MDS2

# Necessary if using MDSout:
MDSout$NMDS1 <- MDSout$MDS1
MDSout$NMDS2 <- MDSout$MDS2

# Use if wanting to filter or to remove unwanted columns:
data_scores <- data_scores %>% 
#  filter(tsf_cat <3) %>% 
  dplyr::select(NMDS1, NMDS2, site_id)

```

```{r}
# CA starts here
kclusts <- tibble(k = 1:6) %>%
  mutate(
    kclust = map(k, ~kmeans(data_scores, .x)),
    tidied = map(kclust, tidy),
    glanced = map(kclust, glance),
    augmented = map(kclust, augment, data_scores)
  )

kclusts

clusters <- kclusts %>%
  unnest(tidied)

assignments <- kclusts %>% 
  unnest(augmented)

clusterings <- kclusts %>%
  unnest(glanced, .drop = TRUE)

p1 <- ggplot(assignments, aes(NMDS1, NMDS2)) +
  geom_point(aes(color = .cluster)) + 
  facet_wrap(~ k)
p1

clusters$NMDS1 <- clusters$x1
clusters$NMDS2 <- clusters$x2

p2 <- p1 + geom_point(data = clusters, size = 10, shape = "x")
p2

ggplot(clusterings, aes(k, tot.withinss)) +
  geom_line()

```

## Cluster analysis (without dplyr, problematic)
```{r eval=F}
### Cluster analysis
mydata <- scale(plant_matrix[, -1]) # standardize variables

# Determine number of clusters
wss <- (nrow(mydata) - 1) * sum(apply(mydata, 2, var))
for (i in 2:15) wss[i] <- sum(kmeans(
    mydata,
    centers = i
  )$withinss)
plot(
  1:15, wss, type = "b", xlab = "Number of Clusters",
  ylab = "Within groups sum of squares"
)

# K-Means Cluster Analysis
fit <- kmeans(mydata, 3) # 3 cluster solution
# get cluster means
aggregate(mydata, by = list(fit$cluster), FUN = mean)
# append cluster assignment
mydata <- data.frame(mydata, fit$cluster)

# K-Means Clustering with 6 clusters
fit <- kmeans(mydata, 6)

# Cluster Plot against 1st 2 principal components
# vary parameters for most readable graph
library(cluster)
clusplot(mydata, fit$cluster, color = TRUE, shade = TRUE, labels = 2, lines = 0) # not working

# Trying to fix clusplot to use prcomp instead of princomp, which doesn't work with more variables than observations, but it's nor working
newtble <- prop.table(data.matrix(mydata), 1) * 100
num.clust <- 3
clusplotMW <- cluster:::clusplot.default # Create a copy of the two necessary functions for clusplot that route to princomp
mkCheckMW <- cluster:::mkCheckX
body(mkCheckMW) <- parse(text = gsub("princomp", "prcomp", deparse(body(mkCheckMW)))) # replace princomp with prcomp in our copy
body(clusplotMW) <- parse(text = gsub("mkCheckX", "mkCheckMW", deparse(body(clusplotMW)))) # route our clusplot to our mkCheckXW
clusplotMW(newtble, fitnw$cluster, color = T, shade = T, lines = 0)

# Centroid Plot against 1st 2 discriminant functions
library(fpc)
plotcluster(mydata, fit$cluster)

# checking to see which sites are in which groups.... basically makes no sense at all.
mydata_clusters <- as.data.frame(cbind(site_id = plant_matrix$site_id, cluster = fit$cluster))
mydata_clusters <- left_join(mydata_clusters, site_data, by = "site_id")
```


# Plot NMDS results
## Plot using ggplot (better?)
```{r}
ggplot() + 
  geom_polygon(data=hull.data,aes(x=NMDS1,y=NMDS2,fill=tsf_cat,group=tsf_cat),alpha=0.30) + # add the convex hulls
  geom_text(data=species_scores,aes(x=NMDS1,y=NMDS2,label=species),alpha=0.5) +  # add the species labels
  geom_point(data=data_scores,aes(x=NMDS1,y=NMDS2,shape=tsf_cat,colour=tsf_cat),size=3) + # add the point markers
  geom_text(data=data_scores,aes(x=NMDS1,y=NMDS2,label=site_id),size=6,vjust=0) +  # add the site labels
#  scale_colour_manual(values=c("A" = "red", "B" = "blue")) +
  coord_equal() +
  theme_bw() + 
  theme(axis.text.x = element_blank(),  # remove x-axis text
        axis.text.y = element_blank(), # remove y-axis text
        axis.ticks = element_blank(),  # remove axis ticks
        axis.title.x = element_text(size=18), # remove x-axis labels
        axis.title.y = element_text(size=18), # remove y-axis labels
        panel.background = element_blank(), 
        panel.grid.major = element_blank(),  #remove major-grid labels
        panel.grid.minor = element_blank(),  #remove minor-grid labels
        plot.background = element_blank())

```

## Categories for old school plot (pick)
```{r eval = F}
# just severity
hi <- data_scores[data_scores$sev == "h", ][chull(data_scores[data_scores$sev == 
    "h", c("NMDS1", "NMDS2")]), ]  # hull values for grp A
lo <- data_scores[data_scores$sev == "l", ][chull(data_scores[data_scores$sev == 
    "l", c("NMDS1", "NMDS2")]), ]  # hull values for grp B
un <- data_scores[data_scores$sev == "u", ][chull(data_scores[data_scores$sev == 
    "u", c("NMDS1", "NMDS2")]), ]  # hull values for grp B

hull.data <- rbind(hi, lo, un)  #combine grp.a and grp.b
hull.data


# just tsf in bins
recent <- data_scores[data_scores$tsf_cat == "1", ][chull(data_scores[data_scores$tsf_cat == 
    "h", c("NMDS1", "NMDS2")]), ]  # hull values for grp A
mid <- data_scores[data_scores$tsf_cat == "2", ][chull(data_scores[data_scores$tsf_cat == 
    "l", c("NMDS1", "NMDS2")]), ]  # hull values for grp B
maturing <- data_scores[data_scores$tsf_cat == "3", ][chull(data_scores[data_scores$tsf_cat == 
    "u", c("NMDS1", "NMDS2")]), ]  # hull values for grp B
old <- data_scores[data_scores$tsf_cat == "4", ][chull(data_scores[data_scores$tsf_cat == 
    "u", c("NMDS1", "NMDS2")]), ]  # hull values for grp B

hull.data <- rbind(recent, mid, maturing, old)  #combine grp.a and grp.b
hull.data

```

## Old school plotting (continued)
```{r eval = F}
# old school plotting method:
plot(metaMDS)
ordiplot(metaMDS, type = "n")
orditorp(metaMDS, display = "species", col = "red", air = 0.01)

# note that the sites are not the right numbers on the graph
orditorp(metaMDS, display = "sites", cex = 1.25, air = 0.01)

# not sure the following works properly, but can be included directly into ordihull call
treat <- site_data$sev

ordiplot(metaMDS, type = "n")
ordihull(metaMDS, groups = treat, draw = "polygon", col = "grey90", label = F)

orditorp(metaMDS, display = "species", col = "red", air = 0.01)
orditorp(metaMDS, display = "sites", col = c(rep("green", 5), rep("blue", 5)), air = 0.01, cex = 1.25)


# write output
# write.csv(NMDS$points, file = "NMDS_out.csv")
```

## Plot NMDS results (from before I figured out how to plot directly)
```{r}
# dplyr::select desired dataset
MDSout <- read.csv("~/Desktop/Davis/R/GitHub Repos/Fire_mosaics/output/NMDS_out.csv")
MDSout <- read.csv("~/Desktop/Davis/R/GitHub Repos/Fire_mosaics/output/NMDS_all_natives.csv")
MDSout <- read.csv("~/Desktop/Davis/R/GitHub Repos/Fire_mosaics/output/NMDS_only_trees.csv")
MDSout <- read.csv("~/Desktop/Davis/R/GitHub Repos/Fire_mosaics/output/NMDS_only_shrubs.csv")
MDSout <- read.csv("~/Desktop/Davis/R/GitHub Repos/Fire_mosaics/output/NMDS_grass_herbs.csv")
MDSout <- read.csv("~/Desktop/Davis/R/GitHub Repos/Fire_mosaics/output/NMDS_herbs_only.csv")
```

```{r}
# Use ggplot to make plot
MDSout <- cbind(MDSout, site_id = plant_matrix$site_id)
MDSout <- left_join(MDSout, site_data, by = "site_id")


ggplot(data = MDSout, aes(MDS2, MDS1), color = "tsf") +
  geom_point(mapping = aes(x = MDS2, y = MDS1, color = tsf, shape = sev), size = 2) +
  theme_bw() +
  scale_color_viridis() +
  # scale_shape_manual(values=c(0,17)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  stat_ellipse(geom = "polygon", alpha = 0.05, aes(fill = sev), level = 0.9)

# text(NMDS, disp=c("species"), col=c("red"), cex=0.7)
```

# PERMANOVA
## Main PERMANOVA
We see using the permanova that there is no difference between low sev and unburnt. There is a difference with high sev though. No detectable effect of time since fire, but further analysis is necessary (ie is there an effect with high sev).
```{r}
# Main PERMANOVA
comp.data <- left_join(plant_matrix, site_data, by = "site_id") %>% 
  mutate(sev2 = ifelse(sev == 'h' , "h", "lu"))
comp.data$sev <- as.character(comp.data$sev)

### Pairwise PERMANOVA can be done with package RVAideMemoire
### install.packages("RVAideMemoire")
### library(RVAideMemoire)
### adonis(comp.data[,6:59]~cover,data=comp.data,method="euclidian")
### pairwise.perm.manova(dist(comp.data[,6:59], "euclidean"),comp.data$forest_moisture,nperm=999)

# Pick among the following
## Is there an effect of severity and time since fire?
comp.sub <- subset(comp.data, sev != "h" | sev == "h", dplyr::select = ACTR:WHMO)
comp.env <- subset(comp.data, sev != "h" | sev == "h", dplyr::select = c(fire:tsf_cat))
attach(comp.env)
adonis2(comp.sub ~ sev * tsf_cat)

## Is there an effect of severity and time since fire if low sev and unburnt are pooled?
comp.sub <- subset(comp.data, dplyr::select = ACTR:WHMO)
comp.env <- subset(comp.data, dplyr::select = c(fire:sev2))
attach(comp.env)
adonis2(comp.sub ~ sev2 * tsf_cat)

```

## Pairwise PERMANOVA function
```{r}
### Pairwise PERMANOVA (code from https://www.researchgate.net/post/How_can_I_do_PerMANOVA_pairwise_contrasts_in_R)
pairwise.adonis <- function(x, factors, sim.method = "bray", p.adjust.m ="bonferroni") {
  library(vegan)
  co <- combn(unique(factors), 2)
  pairs <- c()
  F.Model <- c()
  R2 <- c()
  p.value <- c()

  for (elem in 1:ncol(co)) {
    ad <- adonis(x[factors %in% c(co[1, elem], co[2, elem]), ] ~ factors[factors %in% c(co[1, elem], co[2, elem])], method = sim.method)
    pairs <- c(pairs, paste(co[1, elem], "vs", co[2, elem]))
    F.Model <- c(F.Model, ad$aov.tab[1, 4])
    R2 <- c(R2, ad$aov.tab[1, 5])
    p.value <- c(p.value, ad$aov.tab[1, 6])
  }
  p.adjusted <- p.adjust(p.value, method = p.adjust.m)
  pairw.res <- data.frame(pairs, F.Model, R2, p.value, p.adjusted)
  return(pairw.res)
}

```

## Pairwise PERMANOVA function (pt.2)
```{r}
### below is an attempt to show Df, but output is screwy

pairwise.adonis <- function(x, factors, sim.method = "bray", p.adjust.m ="bonferroni") {
  library(vegan)
  co <- combn(unique(factors), 2)
  pairs <- c()
  Df <- c()
  F.Model <- c()
  R2 <- c()
  p.value <- c()

  for (elem in 1:ncol(co)) {
    ad <- adonis(x[factors %in% c(co[1, elem], co[2, elem]), ] ~ factors[factors %in% c(co[1, elem], co[2, elem])], method = sim.method)
    pairs <- c(pairs, paste(co[1, elem], "vs", co[2, elem]))
    Df <- c(Df, ad$aov.tab[1, ])
    F.Model <- c(F.Model, ad$aov.tab[1, 4])
    R2 <- c(R2, ad$aov.tab[1, 5])
    p.value <- c(p.value, ad$aov.tab[1, 6])
  }
  p.adjusted <- p.adjust(p.value, method = p.adjust.m)
  pairw.res <- data.frame(pairs, Df, F.Model, R2, p.value, p.adjusted)
  return(pairw.res)
}
```

## Pairwise PERMANOVA function (run)
```{r}
pairwise.adonis(comp.sub, comp.data$sev)
```

# Indicator species analysis
```{r}
### Community data matrix
plant_data_filtered <- left_join(plant_data, site_data, by = "site_id") 

plant_dat <- left_join(plant_data_filtered, plant_names, by = "species") %>%
  filter(native_status == "native") %>%
  mutate(sev_tsf = paste(sev, tsf_cat, sep = "")) %>% 
  mutate(sev2 = ifelse(sev == 'h' , "h", "lu")) 
#%>%  filter(sev == "l")

plant_dat$fire_yr <- as.numeric(as.character(plant_dat$fire_yr))
plant_dat$tsf <- as.numeric(as.character(plant_dat$tsf))

plant_dat <- mutate(plant_dat, tsf_cat2 = ifelse(tsf < 20 , "1", "2")) 

plant_dat_select  <- plant_dat %>%
  dplyr::select(site_id, species, cover)

plant_matrix1 <- spread(data = plant_dat_select, key = species, value = cover, fill = 0)

plants_matrix <- as.matrix(plant_matrix1[, -1])

d <- plant_matrix
data <- d[,-1]

### Vector for site classification
### severity
groups1 = as.vector(plant_dat$sev)
#groups1 = as.vector(plant_dat$tsf_cat2)
#groups1 = as.vector(plant_dat$sev_tsf)

Indval_out1 <- indval(data, groups1, numitr=10000)
gr <- Indval_out1$maxcls[Indval_out1$pval<=0.05]
iv <- Indval_out1$indcls[Indval_out1$pval<=0.05]
pv <- Indval_out1$pval[Indval_out1$pval<=0.05]
fr <- apply(data>0, 2, sum)[Indval_out1$pval<=0.05]
indvalsummary <- data.frame(group=gr, indval=iv, pvalue=pv, freq=fr)
indvalsummary1 <- indvalsummary[order(indvalsummary$group, -indvalsummary$indval),]
prob.corrected1 = p.adjust(Indval_out1$pval, "BH") # correct p.value for multiple testing
View(indvalsummary1)

#write.csv(indvalsummary1, file = "indvalsummary1.csv")
#write.csv(prob.corrected1, file = "prob.corrected1.csv")
```

```{r eval=FALSE}
###Rarefaction curves (not working)
rare <- plant_matrix
raredata <- rare[,-1]
raredata[raredata > 0] <- 1 # transform into presence/absence
rarecurve(raredata, xlab = "Cumulative number of individuals", ylab = "Number of species")

### trying indicspecies. This combines habitat clusters too.
options(max.print=1000000)
indval <- multipatt(data, groups1, func = "IndVal.g", control = how(nperm = 999), max.order = 6)
indval
summary(indval, alpha=1)
summary(indval)
indval$sign

### Can also use combinations of species as indicators, but this is not very interesting (?). 
spcomb <- combinespecies(data, max.order = 3)$XC
indvapspcomp <- multipatt(spcomb, groups1, duleg = TRUE, control = how(nperm = 999))
summary(indvapspcomp)
```